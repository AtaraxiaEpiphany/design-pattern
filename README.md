# 设计模式分类

* **创建型模式**

  用于描述`怎样创建对象`，它的主要特点是`将对象的创建与使用分离`。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等
  5 种创建型模式。

* **结构型模式**

  用于描述`如何将类或对象按某种布局组成更大的结构`，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。

* **行为型模式**

  用于`描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责`
  。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。

# UML类图

## 表示方法

属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：

* +：表示public
* -：表示private
* #：表示protected

`属性`的完整表示方式是： **可见性 名称 ：类型 [ = 缺省值]**

`方法`的完整表示方式是： **可见性 名称(参数列表) [ ： 返回类型]**

## 关系的表示

从变量的角度来考虑:

- 关联关系:成员变量
- 依赖关系:局部变量(方法的参数,静态方法调用)
- 组合关系:构造方法注入.
- 聚合关系:set方法注入.
- 继承关系:extends
- 实现关系:implements

## 软件设计原则

> 开闭原则是目标,里氏代换原则是基础,依赖倒转原则是手段.

- 维护性
- 扩展性
- 灵活性
- 扩展性

### 开闭原则(Open Closed Principle)

> 对扩展开放,对修改关闭.是程序易于维护,扩展和升级.
>
> 一般使用接口和抽象类定义规范来满足开闭原则.

### 里氏代换原则(Liskov Substitution Principle)

> 任何基类（父类）能出现的地方，子类也应该能够出现，而且能够替换基类而不影响程序的正确性.
>
> 子类在继承父类时,除了添加新的方法完成新功能外,尽量不重写父类方法.

### 依赖倒转原则(Dependency Inversion Principle)

> 它强调了高层模块不应该依赖于低层模块的具体实现，而应该依赖于抽象接口或抽象类。
>
> Controller依赖于Service接口而不是ServiceImpl.

### 接口隔离原则(Interface Segregation Principle)

> 接口隔离原则的核心思想是：应该将大型接口拆分为更小、更具体的接口，
> 以满足客户端的实际需求。这样可以避免客户端依赖于不需要的接口方法，减少接口的冗余和臃肿。
>
> 实际应用中类可以多实现,将功能拆分成更小的接口,按需实现接口.

### 迪米特法则,又称最少知识原则(Principle of Least Knowledge)

> 一个对象应该对其他对象有尽可能少的了解，只与直接的朋友通信。
>
> 直接的朋友指的是以下几种情况：

- 当前对象本身。
- 被当前对象作为方法参数传入的对象。
- 当前对象的成员变量。

> 为了遵循迪米特原则，需要注意以下几点：

- 尽量减少对象之间的直接交互，通过封装和提供合适的接口进行通信。
- 不要在一个对象的方法中调用其他对象的方法，并且避免链式调用过多的方法。
- 尽量将复杂的业务逻辑封装在对象内部，而不是暴露给外部对象。

### 合成复用原则(Composite Reuse Principle)

> 在系统设计中应该优先使用对象聚合或组合（composition）而不是继承（inheritance）来实现代码的复用。

### 单一职责原则(Single Responsibility Principle)

> 一个类或模块应该有且仅有一个引起它变化的原因.
> 一个类或模块应该只负责一项职责或功能。

# 设计模式

## 创建者模式(Creation Pattern)

> 该模式关注对象的创建机制，帮助解决对象创建过程中的灵活性和复杂性问题。

### **单例设计模式(Singleton Pattern)**

单例模式角色

- 单例类:只能创建一个实例的类.
- 访问类:使用单例类.

#### 饿汉式(Eager Initialization)

> 实例在类加载时就被创建，因此它是线程安全的.无论是否使用该实例，都会在类加载时创建实例。

#### 懒汉式(Lazy Initialization)

> 在懒汉式中，实例的创建被延迟到第一次使用时，也就是在调用 getInstance() 方法时才会创建实例。
> 这种方式可以避免不必要的实例创建，但需要注意线程安全性。

- Double check:存在线程安全,若对方法上锁太重.由于绝大部分操作是读操作,线程安全.只需在内部创建对象前双重判断上锁即可.
- Static inner class:静态内部类只有调用其属性或者方法才被加载,因此属于lazy load.并且由于静态内部类的属性被static修饰,因此只会实例化一次.
- Enumeration: 饿汉式,不会被序列化反序列化/反射破坏.

> 反射与序列化都使得单例模式被破坏(得到了两个不同的单例类)

### 工厂设计模式(Factory Design Pattern)

> 它提供了一种创建对象的方式，将对象的创建逻辑封装在工厂类中，而不是直接在代码中使用new关键字来实例化对象。
> 这样可以降低代码的耦合性，提高代码的可维护性和可扩展性。
>
> 工厂设计模式通常涉及以下几个角色：

- 抽象产品（Abstract Product）：定义产品的共同接口或抽象类，具体产品需要实现这个接口或继承这个抽象类。
- 具体产品（Concrete Product）：实现抽象产品接口或继承抽象产品类，是工厂创建的目标对象。
- 抽象工厂（Abstract Factory）：定义创建产品的接口，可以是抽象类或接口。通常包含一个或多个创建产品的方法。
- 具体工厂（Concrete Factory）：实现抽象工厂接口，负责创建具体产品的对象。

#### 简单工厂模式

> 封装了对象创建的过程,可以通过`参数`来获取对象.
> 把对象的创建与业务逻辑分开.
>
> 缺点:增加新产品时需要修改工厂类代码,违背了`单一职责原则`.

#### **工厂方法模式**

> 符合开闭原则，可以通过添加新的具体工厂和具体产品来扩展系统，而无需修改现有的代码。
>
> 当需要在多个相关的产品系列中选择一个时，可以使用工厂方法模式来实现产品族的创建。
>
> JDK中Collection.Iterator使用了工厂方法模式,Collection是抽象工厂,Iterator是抽象产品.ArrayList是具体工厂,ArrayList.Itr是具体产品.

#### 抽象工厂模式

> 使用工行方法模式在某些场景会有太多的具体工厂和具体方法(类爆炸),抽象工厂使得工厂的职责更为抽象.
> 遵循了依赖倒装原则.可能违背了单一职责原则(生产一组相关的对象),接口隔离原则,
> 开闭原则(当需要添加产品族到抽象工厂,所有的工厂都得修改).
>
> 使用场景:

- 当需要创建一组相关或相互依赖的产品对象时，可以使用抽象工厂模式。
- 当需要提供一个统一的接口来创建相关或依赖对象的时候，可以使用抽象工厂模式。
- 当系统需要独立于其产品的创建、组合和表示时，可以使用抽象工厂模式。

#### **工厂模式拓展**

> 使用简单工厂模式+配置文件+反射解除耦合.
>
> 在工厂类中使用一个Map容器保存不同的产品对象,通过配置文件中的全路径类名加反射创建产品对象并保存到容器中.

### 原型模式(Prototype Pattern)

> 用一个已经创建的实例作为原型,通过复制该原型来创建一个与原型相同的对象.
>
> 原型模式中有三个角色:

- 原型接口（Prototype Interface）：定义了克隆方法（clone），该方法用于复制对象。所有具体原型类都必须实现该接口。在Java中Cloneable接口是一个原型接口.
- 具体原型类（Concrete Prototype Class）：实现了原型接口，实现了克隆方法。具体原型类是被复制的对象，通过克隆方法可以创建与原型对象相同的新对象。
- 客户端（Client）：使用原型模式的客户端代码。它通过克隆原型对象来创建新对象，而无需直接实例化具体原型类。

> 原型模式中的克隆可以是潜拷贝(shallow copy)和深拷贝(deep copy):

- 浅拷贝: 在克隆方法中，只复制对象本身，而不复制对象的关联对象。克隆对象和原型对象会共享相同的关联对象，因此对关联对象的修改会影响到两者。
- 深拷贝:
  在克隆方法中，除了复制对象本身外，还会递归复制对象的所有关联对象和属性。这样可以实现对整个对象图的完全复制，确保克隆对象与原型对象完全独立。可以使用序列化来实现(
  序列化可以破坏单例)

### **建造者模式(Builder Pattern)**

> 使用建造者模式，可以将对象的构建过程与其表示分离，从而可以使用相同的构建过程来创建不同的表示。
>
> 建造者模式通常包含了以下角色:
> 产品（Product）：表示被构建的复杂对象。它通常包含多个组成部分，这些部分的构建过程由具体的建造者负责。

- 抽象建造者（Builder）：定义了创建产品的步骤和方法。它通常包含一个用于构建产品的抽象接口。
- 具体建造者（Concrete Builder）：实现了抽象建造者的接口，负责实际构建产品的各个部分，并定义返回最终产品的方法。
- 产品（Product）：表示被构建的复杂对象。它通常包含多个组成部分，这些部分的构建过程由具体的建造者负责。
- 指挥者（Director）：负责使用建造者对象构建最终的产品。它定义了构建的顺序和流程，以及如何调用建造者的方法来构建产品。

#### 拓展

- 链式调用:通过在建造者方法中返回自身（this），可以实现连续调用建造者的方法，使代码更具流畅性。
- 应用于函数式编程：在函数式编程中，可以使用Lambda表达式或函数式接口来实现建造者模式。通过传递不同的构建逻辑或函数，可以实现更灵活的对象构建过程。

#### 区别

- 工厂方法模式关注的是创建单个整体对象的过程，通过定义一个工厂方法来创建对象，将对象的创建过程封装在工厂类中。
- 抽象工厂模式关注的是创建一系列相关或相互依赖的对象，通过定义一个抽象工厂接口来创建这些对象，将对象的创建过程封装在具体工厂中。
- 建造者模式关注的是创建复杂对象的过程，将对象的构建和表示分离，通过指挥者逐步构建各个部分来创建对象。

## 结构型模式(Structural Pattern)

> 结构型模式分为类结构性模式和对象结构性模式(满足合成复用原则)，
> 这些模式主要关注对象的组合、接口的定义和实现以及类之间的关系，以及如何构建更大的结构和对象之间的关系。

### **代理模式**

> 代理模式允许通过创建一个代理对象来控制对另一个对象的访问。
> 代理对象充当了客户端与目标对象之间的中介，客户端通过代理对象间接地访问目标对象，并可以在访问过程中添加额外的逻辑。
>
> 代理模式一般设计以下角色:

- 抽象主题（Subject）：定义了真实主题和代理主题之间的共同接口。抽象主题可以是一个接口或抽象类，它声明了客户端可以调用的方法。
- 真实主题（Real Subject）：定义了代理对象所代表的真实对象。真实主题是实现了抽象主题接口的类，它执行实际的业务逻辑。
- 代理（Proxy）：实现了抽象主题接口，并持有一个真实主题的引用。代理对象可以在调用真实主题之前或之后执行一些额外的操作，以控制对真实主题的访问。

#### 静态代理

> 静态代理是在编译时就已经创建好代理类的方式。
> 在静态代理中，需要手动创建一个代理类，该代理类实现了与被代理类相同的接口(抽象主题)，并在方法中调用被代理类(真实主题)的方法。
> 静态代理的优点是简单易懂，但缺点是每个被代理类都需要对应一个代理类，导致代码冗余。

#### 动态代理

- `JDK动态代理`
  是基于接口的代理。使用`Proxy`类和`InvocationHandler`接口来实现。代理类实现了被代理接口(抽象主题)
  ,并在InvocationHandler的invoke方法中调用被代理对象(真实主题)的方法。
- `CGLib动态代理`是基于类的代理。使用CGLib库生成代理类，代理类是被代理类(真实主题)
  的子类，通过`setCallback`添加给`Enhancer`额外的逻辑。CGLib动态代理可以代理没有实现接口的类。

### **适配器模式(Adapter Pattern)**

> 将一个类的接口转换成客户端所期望的另一个接口，解决不兼容接口之间的兼容性问题。
>
> 主要角色:

- 目标接口（Target Interface）：客户端所期望的接口，适配器将目标接口转换成被适配者的接口。
- 适配者（Adaptee）：需要被适配的类或接口。它定义了客户端不能直接使用的接口。
- 适配器（Adapter）：他是一个转换器,将被适配者的接口转换成目标接口的类。它实现了目标接口.

#### 类适配器(Class Adapter)

> 定义一个适配器类(Adapter)来实现系统的业务接口(Target Interface)并继承被适配者(Adaptee).
> 违背了`合成复用原则`,使得适配器与适配者接口高度耦合.

#### 对象适配器(Object Adapter)

> 适配器类通过持有一个被适配者类(Adaptee)的实例，并实现了目标接口(Target Interface)，
> 从而使得客户端可以通过目标接口与被适配者类进行交互。

#### 接口适配器(Interface Adapter)

> 用于解决接口之间的适配问题。接口适配器模式主要用于当一个接口中定义的方法过多时，
> 而实现该接口的类并不需要全部实现这些方法的情况。
>
> 具体实现:引入一个`抽象类`作为适配器，该抽象类`实现目标接口`，
> 并为该接口中的每个方法提供一个默认的`空实现`。
> 然后，具体的适配器类继承这个抽象类，`按需override`抽象类方法。

### **装饰器模式(Decorator Pattern)**

> 它允许在不改变已有对象的基础上，动态地扩展其功能。
>
> 主要角色:

- 抽象组件（Component）：定义一个抽象接口，可以是一个抽象类或接口，它是被装饰的原始对象和装饰器对象的共同接口。
- 具体组件（Concrete Component）：实现抽象组件接口，是被装饰的原始对象，它定义了被装饰对象的基本行为。
- 抽象装饰器（Decorator）：也是抽象组件的子类，它持有一个`抽象组件的引用`，并定义与抽象组件一致的接口。抽象装饰器的目的是为了扩展抽象组件的功能。
- 具体装饰器（Concrete Decorator）：实现抽象装饰器接口，是具体的装饰器对象。具体装饰器通过持有一个抽象组件的引用，并在其上添加额外的功能或修改原始对象的行为。

#### 扩展

> `Component`以及`Concrete Component`分别作为`Product`和`Concrete Product`,
> 并通过一个抽象工厂类来创建抽象装饰器`Decorator`,该类内部持有一个`Component`对象的引用依赖,
> 工厂内部createDecorator方法使用`Function<component,component> function`作为参数,
> 在具体工厂中传入Function参数来定义不同的Decorator装饰器行为.

### 桥接模式(Bridge Pattern)

> 桥接模式用于将抽象部分与实现部分分离，以便它们可以独立地变化。
> 该模式通过将继承关系改为关联关系，使得抽象部分和实现部分可以独立地进行扩展。
>
> 主要角色:

- 抽象化（Abstraction）：定义抽象部分的接口，维护一个指向`实现部分(Implementor)`的引用。
- 具体抽象化（Concrete Abstraction）：实现抽象部分的接口，继承抽象部分，并调用实现部分的方法。
- 实现化（Implementor）：定义实现部分的接口，供具体实现部分实现。
- 具体实现化（Concrete Implementor）：实现实现部分的接口。

### 外观模式(Facade Pattern)

> 外观模式提供了一个统一的接口，用于访问子系统中的一组接口.
> 通过提供一个简化的接口，外观模式隐藏了子系统的复杂性，使得客户端更容易使用子系统(最少知识原则)。
> 它通过创建一个高层接口，将多个低层接口封装在一起，对外提供更简单、更易于使用的接口.
>
> 主要角色:

- Facade（外观）：外观类是外观模式的核心，它提供了一个简化的接口，封装了对子系统的复杂操作。它知道哪些子系统类负责处理请求，并将客户端的请求转发给适当的子系统对象。
- Subsystem（子系统）：子系统是一组类或组件，实现了子系统的功能。

> 外观模式遵循了最少知识法则,但违背了开闭原则.如果需要添加子系统时,则不得不修改外观类代码.

### **组合模式(Composite Pattern)**

> 它允许将对象组合成树形结构以表示"部分-整体"的层次结构。
> 组合模式使得客户端可以统一处理单个对象和组合对象，而无需区分它们的具体类型。
>
> 主要角色:

- 抽象根节点(Component):定义组合对象和叶子对象的共同接口，可以是抽象类或接口。它声明了组合对象和叶子对象的一些共同操作.
- 组合(树节点)对象(Composite):组合对象可以包含其他组合对象或叶子对象，形成递归的树形结构。
- 叶子对象(根节点)(Leaf):叶子对象是组合对象中的最小单位，它们没有子对象。

#### 组合模式分类

##### 安全式组合模式(Safe Composite Pattern)：

> 在安全式组合模式中，组件接口（Component）只包含对叶子对象的操作，而不包含对组合对象的操作。
> 具体的组合对象（Composite）类负责管理子节点的添加、删除和获取操作。
> 这种方式相对较安全，因为客户端只能通过组合对象来操作子节点，而无法直接操作叶子对象。
> 安全式组合模式的一个典型实现是将组件接口定义为抽象类，其中只包含对叶子对象的操作，
> 而具体的组合对象类实现了对组合对象的操作。

##### 透明式组合模式(Transparent Composite Pattern)：

> 在透明式组合模式中，组件接口（Component）包含对叶子对象和组合对象的操作。
> 这意味着客户端可以通过组件接口直接操作叶子对象和组合对象，而无需区分它们的具体类型。
> 透明式组合模式的一个典型实现是将组件接口定义为抽象类或接口，其中包含对叶子对象和组合对象的操作，
> 而具体的叶子对象类和组合对象类都实现了该接口。

### **享元模式(Flyweight Pattern)**

> 享元模式旨在通过共享对象来减少内存使用和提高性能。
> 在享元模式中，对象被分为可共享的内部状态(Intrinsic State)不可共享的外部状态(Extrinsic State)。
> 内部状态是对象的固有属性，可以在多个对象之间共享且不会随着环境改变，
> 而外部状态是对象的上下文相关的属性，每个对象都有自己的外部状态。
>
> 主要角色:

- Flyweight（享元）：它是一个接口或抽象类，定义了享元对象的接口和方法。它包含了可以被共享的内部状态（Intrinsic
  State）和操作方法，同时也可以通过这些方法设置外部状态(Extrinsic State)。
- ConcreteFlyweight（具体享元）：实现了Flyweight接口，并实现了共享的内部状态。具体享元对象可以被共享和重用，因此它们必须是无状态的或可共享状态的。
- UnsharedConcreteFlyweight（非共享具体享元）：在享元模式中，有时候可能存在非共享的具体享元对象。这些对象不会被共享，因此可以有自己的状态。
- FlyweightFactory（享元工厂）：负责创建和管理享元对象。它维护一个享元池(Flyweight Pool)
  来存储已经创建的享元对象，并在需要时返回已有的对象或创建新的对象。享元工厂通常提供一个获取享元对象的方法，该方法接受外部状态作为参数，并根据外部状态返回相应的享元对象。

> Integer内部用到了flyweight pattern,内部维护了一个flyweight pool.

```
public static Integer valueOf(int i){
    if(i>=IntegerCache.low&&i<=IntegerCache.high)
      return IntegerCache.cache[i+(-IntegerCache.low)];
    return new Integer(i);
} 
```

## 行为型模式(Behavioral Pattern)

> 该模式关注对象之间的通信和交互，以解决对象之间的责任分配和算法封装等问题。

### 模板方法模式(Template Method Pattern)

> 模板方法定义了一个算法的骨架，将一些步骤的实现延迟到子类中。
> 在模板方法模式中，算法的结构不会改变，但是某些步骤的具体实现可以在子类中进行自定义。
>
> 主要角色:

- 抽象类(Abstract Class):模板方法定义了算法的结构，抽象方法由子类来实现具体的步骤，具体方法提供了共享的行为，而钩子方法允许子类影响算法的行为。
    - 模板方法(Template Method)：定义了算法的骨架,内部按照一定的顺序调用其他方法来完成算法的执行。
    - 抽象方法(Abstract Method)：用于定义算法中的特定步骤,需要子类来实现，以完成算法的具体实现。
    - 具体方法(Concrete Method)：具体方法在抽象类中直接提供默认实现，也可以在子类中进行重写。具体方法通常是模板方法中的一部分，用于执行算法中的共享行为。
    - 钩子方法(Hook Method)：钩子方法是在抽象类中定义的具体方法(已经有默认实现)
      ，子类可以选择性地进行重写。钩子方法通常用于影响算法的行为，允许子类在模板方法的执行过程中插入自定义的逻辑。
- 具体类(Concrete Class):
  具体类在模板方法模式中起到了实际实现算法的作用，通过提供具体的实现细节来完成算法的执行。每个具体类都可以根据自身的需求来实现抽象方法，并可以选择性地重写钩子方法，以便在模板方法的执行过程中插入自定义的逻辑。

### **策略模式(Strategy Pattern)**

> 策略模式允许在运行时选择算法的行为。
> 该模式将算法封装在独立的策略类中，使得它们可以相互替换，而不影响使用算法的客户端。
>
> 主要角色:

- 上下文(Context): 上下文对象是策略模式的核心，它持有一个对`策略接口`的引用，并在运行时根据需要切换具体的策略对象。上下文对象将具体的算法委托给策略对象来执行。
- 抽象策略(Strategy):策略接口定义了具体策略类必须实现的算法方法。它通常是一个接口或抽象类，声明了策略类应该实现的方法。
- 具体策略(Concrete Strategy):具体策略类实现了策略接口定义的算法。每个具体策略类都提供了一种不同的算法实现。

> Arrays.sort(T[] a, Comparator<? super T> c) 使用了策略模式,可以动态的以lambda形式传入Concrete Strategy来选择不同的算法策略.

```
/**
  * Strategy.
  */
public interface Comparator<T> {
  int compare(T o1, T o2);
}
```

### 命令模式(Command Pattern)

> 命令模式请求封装成一个对象，使得发出的请求与执行的责任分开。
> 从而使得发送者不需要知道具体的接收者，只需通过`命令对象`来执行请求。
>
> 主要角色:

- 命令（Command）：定义了执行操作的接口。通常包含一个执行（execute）方法，用于执行具体的操作。命令对象可以封装一系列操作，包括调用接收者的方法、传递参数等。
- 具体命令（Concrete Command）：实现了命令接口，具体命令类将具体的操作绑定到`接收者`上。它包含了`接收者`对象，并在执行方法中调用接收者的相应操作。
- 调用者/请求者（Invoker）：负责调用`命令对象`来执行请求。它持有一个`命令对象`，并在需要执行请求时调用命令对象的执行方法。
- 接收者/实现者（Receiver）：`执行实际操作的对象`。接收者包含了具体的业务逻辑，负责执行`命令对象`所封装的操作。

> Runnable使用了命令模式,Runnable是一个`Command`,Thread是`Invoker`,start是其执行方法.

```
// Command
public interface Runnable {
    public abstract void run();
}
// Invoker
public class Thread implements Runnable {
    /* What will be run. (Command) */
    private Runnable target;
    public synchronized void start() {
        // ...
        /**
         * target.run();
         */
    }
}
```





